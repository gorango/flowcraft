import * as ts from 'typescript'
import * as path from 'path'
import resolve from 'resolve'
import type { CompilationOutput, FileAnalysis } from './types'
import type { WorkflowBlueprint } from 'flowcraft'
import { FlowAnalyzer } from './flow-analyzer'

export class Compiler {
	private program: ts.Program
	private typeChecker: ts.TypeChecker
	public fileCache: Map<string, FileAnalysis> = new Map()

	constructor(private tsConfigPath: string) {
		const config = ts.readConfigFile(tsConfigPath, ts.sys.readFile)
		const parsed = ts.parseJsonConfigFileContent(config.config, ts.sys, process.cwd())
		this.program = ts.createProgram(parsed.fileNames, parsed.options)
		this.typeChecker = this.program.getTypeChecker()
	}

	compileProject(entryFilePaths: string[]): CompilationOutput {
		// Discovery Pass
		this.discoveryPass()

		// Analysis Pass
		const blueprints: Record<string, WorkflowBlueprint> = {}
		const registry: Record<string, { importPath: string; exportName: string }> = {}
		const diagnostics: import('./types').CompilationDiagnostic[] = []

		for (const [filePath, fileAnalysis] of this.fileCache) {
			for (const [exportName, { type, node }] of fileAnalysis.exports) {
				if (type === 'flow') {
					const analyzer = new FlowAnalyzer(this, fileAnalysis.sourceFile, node, this.typeChecker)
					const result = analyzer.analyze()
					blueprints[exportName] = result.blueprint
					Object.assign(registry, result.registry)
					diagnostics.push(...result.diagnostics)
				}
			}
		}

		// Generation Pass
		const manifestSource = this.generateManifest(blueprints, registry)

		return { blueprints, registry, diagnostics, manifestSource }
	}

	private discoveryPass(): void {
		for (const sourceFile of this.program.getSourceFiles()) {
			if (sourceFile.isDeclarationFile) continue
			const filePath = sourceFile.fileName
			const exports = new Map<string, { type: 'flow' | 'step'; node: ts.FunctionDeclaration }>()

			ts.forEachChild(sourceFile, (node) => {
				if (ts.isExportDeclaration(node)) {
					// Handle export { ... }
					if (node.exportClause && ts.isNamedExports(node.exportClause)) {
						node.exportClause.elements.forEach((element) => {
							const symbol = this.typeChecker.getSymbolAtLocation(element.name)
							if (symbol) {
								const declarations = symbol.getDeclarations()
								if (declarations && declarations.length > 0) {
									const decl = declarations[0]
									if (ts.isFunctionDeclaration(decl) && decl.name) {
										const type = 'step' // For now, assume step; can add JSDoc later
										exports.set(element.name.text, { type, node: decl })
									}
								}
							}
						})
					}
				} else if (
					ts.isFunctionDeclaration(node) &&
					node.name &&
					ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export &&
					node.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.AsyncKeyword)
				) {
					const type = 'step' // For now, assume step; can add JSDoc later
					exports.set(node.name.text, { type, node })
				}
			})

			this.fileCache.set(filePath, { filePath, sourceFile, exports })
		}
	}

	private generateManifest(
		blueprints: Record<string, import('flowcraft').WorkflowBlueprint>,
		registry: Record<string, { importPath: string; exportName: string }>,
	): string {
		const imports: string[] = []
		const registryEntries: string[] = []

		for (const [uses, { importPath, exportName }] of Object.entries(registry)) {
			const relativePath = path.relative(process.cwd(), importPath)
			imports.push(`import { ${exportName} } from '${relativePath}'`)
			registryEntries.push(`  '${uses}': ${exportName}`)
		}

		const blueprintEntries = Object.entries(blueprints)
			.map(([id, blueprint]) => `  '${id}': ${JSON.stringify(blueprint, null, 2)}`)
			.join(',\n')

		return `// Generated by @flowcraft/compiler
${imports.join('\n')}

import type { NodeImplementation, WorkflowBlueprint } from 'flowcraft'

export const registry: Record<string, NodeImplementation> = {
${registryEntries.join(',\n')}
}

export const blueprints: Record<string, WorkflowBlueprint> = {
${blueprintEntries}
}
`
	}
}
