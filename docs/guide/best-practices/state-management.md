# Best Practices: State Management

The `Context` is the heart of a running workflow, acting as its shared memory. Managing the state within the `Context` effectively is one of the most important skills for building clean, maintainable, and scalable workflows in Flowcraft.

## 1. Always Use `ContextKey` for Type Safety (In-Memory)

> [!IMPORTANT]
> This is the most important rule for state management. For in-memory workflows, always prefer `contextKey()` over raw strings to access the `Context`.

**Why?**

- **Compile-Time Safety**: The TypeScript compiler will catch typos and type mismatches. If you try to `set` a `number` to a `ContextKey<string>`, your code won't compile.
- **No Typos**: `await ctx.get('user_id')` vs. `await ctx.get('userId')` is a common runtime bug. `await ctx.get(USER_ID)` is checked by the compiler.
- **Easy Refactoring**: Renaming a `ContextKey` is a simple, safe refactoring operation in any modern IDE. Renaming a string key across a large codebase is risky.

```typescript
import { contextKey, TypedContext } from 'flowcraft'

// --- BAD: Using strings ---
const ctxStrings = new TypedContext()
await ctxStrings.set('user_id', 123) // 'user_id' is just a string, no type info
const id_bad = await ctxStrings.get('user_id') // Type is 'any'

// --- GOOD: Using ContextKey ---
const USER_ID = contextKey<number>('A key for the user ID')

const ctxTyped = new TypedContext()
await ctxTyped.set(USER_ID, 123)
const id_good = await ctxTyped.get(USER_ID) // Type is 'number | undefined'
```

> [!WARNING]
> **`ContextKey` vs. Distributed Systems**
>
> `ContextKey`s are `Symbol`s, which are in-memory constructs. They cannot be serialized and sent over a network. When building for a distributed environment (e.g., with a Redis-backed context), you **must** use serializable `string` keys. The declarative `GraphBuilder` is designed with this in mind and operates on string keys.

## 2. Keep the Context Minimal

The `Context` should not be a dumping ground for all data ever generated in the workflow. A lean context makes your workflow easier to debug and reason about.

**Principle**: A piece of data should only be in the `Context` if it is **required by a subsequent node**.

If a node generates intermediate data that is only used within that same node, it should be stored in a local variable, not written to the `Context`.

```typescript
import { Node } from 'flowcraft'

class DataProcessorNode extends Node {
	async exec({ prepRes: data }) {
		// BAD: Don't put temporary data in the context
		// await ctx.set(TEMP_VALUE, data.a + data.b)
		// const intermediate = await ctx.get(TEMP_VALUE)
		// return intermediate * 2

		// GOOD: Use local variables for intermediate steps
		const intermediate = data.a + data.b
		return intermediate * 2
	}
}
```

## 3. Use `params` for Static Input

Distinguish between *dynamic state* and *static configuration*.

- **Dynamic State**: Data generated by a previous node that changes during the workflow's execution. This belongs in the **`Context`**.
- **Static Configuration**: Data provided to a node or flow when it starts, which does not change. This belongs in **`params`**.

Using `params` makes your nodes more reusable and their dependencies more explicit.

```typescript
import { contextKey, Node } from 'flowcraft'

const NUMBER_TO_ADD = contextKey<number>('number_to_add')
const CURRENT_VALUE = contextKey<number>('current_value')

// --- BAD: Configuration is mixed with state ---
// This node's behavior depends on a value that must be in the context.
class AddNumberFromContext extends Node {
	async exec({ ctx }) {
		const valueToAdd = await ctx.get(NUMBER_TO_ADD) // less reusable
		return (await ctx.get(CURRENT_VALUE)) + valueToAdd
	}
}

// --- GOOD: Configuration is passed as a parameter ---
// This node is self-contained. Its configuration comes from its params.
class AddNumberFromParams extends Node {
	async exec({ ctx, params }) {
		const valueToAdd = params.amount // much more reusable
		return (await ctx.get(CURRENT_VALUE)) + valueToAdd
	}
}

// Usage:
const node = new AddNumberFromParams().withParams({ amount: 10 })
```

## 4. Isolate State Within Sub-Flows

When you use composition (a `Flow` within a `Flow`), the sub-flow shares the same `Context` as its parent. To maintain modularity, a sub-flow should not pollute the parent's `Context` with its own internal, temporary state.

**Best Practice**: A sub-flow should only write its final, essential outputs to the `Context`. If possible, use a dedicated output node within the sub-flow to aggregate results and clean up any temporary keys.

The `SubWorkflowNode` in the `sandbox/4.dag` example demonstrates an advanced pattern for this. By defining explicit `input` and `output` maps, it creates a clean data boundary, preventing any leakage of temporary state. For a detailed explanation of this powerful pattern, see the guide on **[Data Flow in Sub-Workflows](./sub-workflow-data.md)**.

## 5. Plan for Serialization

> [!WARNING]
> **Standard `JSON.stringify` is Lossy!**
> While the `InMemoryExecutor` can handle any JavaScript object, your workflow's state may need to be saved or sent over a network (as in the `BullMQExecutor` example). Standard `JSON.stringify` will not correctly preserve complex data types and can lead to silent data loss or bugs.

**Common data types that break `JSON.stringify`:**

- `Date` objects (are converted to strings)
- `Map` and `Set` objects (are converted to empty objects `{}`)
- Custom class instances (lose their methods and class identity)
- `Symbol` keys (are dropped entirely)

To build robust, stateful workflows, it is a best practice to use a library that handles this automatically.

> [!TIP]
> Use a library like [`superjson`](https://github.com/blitz-js/superjson) to serialize and deserialize your context. It transparently handles all common JavaScript types, ensuring that the state you save is the same as the state you load.

The **[Advanced RAG Agent](https://github.com/gorango/tree/master/sandbox/6.rag/) example** was specifically designed to demonstrate this principle. It uses `superjson` to correctly manage a `Context` containing `Map`, `Date`, and custom class instances, making its state reliable and easy to inspect.
