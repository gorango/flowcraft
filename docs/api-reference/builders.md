# API Reference: Builders

Builders are helper classes provided by Flowcraft to abstract away the manual construction of common and complex workflow patterns. They allow you to define high-level behavior, and the builder handles the underlying `Node` and `Flow` wiring for you.

You can import all builders from the main `flowcraft` package.

```typescript
import {
	BatchFlow,
	BlueprintExecutor,
	GraphBuilder,
	ParallelBatchFlow,
	ParallelFlow,
	SequenceFlow,
	WorkflowBlueprint,
} from 'flowcraft'
```

## `GraphBuilder`

A powerful builder that constructs executable workflows from a declarative `WorkflowGraph` definition (e.g., from a JSON file). It is the core of the declarative, distributed-ready architecture.

> [!IMPORTANT]
> To leverage compile-time type safety, you must use the `createNodeRegistry` helper. By defining a `NodeTypeMap` (for your node `data` payloads) and a `TContext` type (for your shared dependencies), TypeScript can validate your entire graph and dependency usage at compile time, eliminating a whole category of runtime configuration errors.

### Constructor

`new GraphBuilder<TNodeMap, TContext>(registry, nodeOptionsContext?, options?, logger?)`

-   `registry: TypedNodeRegistry<TNodeMap, TContext> | NodeRegistry`: An object or `Map` where keys are `type` strings from the graph definition and values are the corresponding `Node` class constructors.
-   `nodeOptionsContext?: TContext`: An optional object passed to every node's constructor, used for type-safe dependency injection.
-   `options?: GraphBuilderOptions`: Optional configuration for sub-workflows and conditional nodes.
    -   `subWorkflowNodeTypes?: string[]`: An array of node `type` strings that should be treated as composable sub-workflows.
    -   `subWorkflowResolver?: SubWorkflowResolver`: An object that implements `{ getGraph(id: string | number): WorkflowGraph | undefined }`. **Required** if you use `subWorkflowNodeTypes`.
    -   `conditionalNodeTypes?: string[]`: An array of node `type` strings whose outgoing edges represent mutually exclusive conditional paths, not parallel branches.
-   `logger?: Logger`: An optional `Logger` instance for receiving internal logs from the builder.

> [!NOTE]
> **Advanced: Overriding Internal Nodes**
>
> The `GraphBuilder` uses several internal node types (e.g., `__internal_input_mapper__`) for structural purposes. You can provide your own `Node` implementation for these types by adding an entry to your `NodeRegistry` with the corresponding internal key. The `GraphBuilder` will detect and use your custom implementation, allowing you to inject custom logic or metrics into the graph's structural scaffolding.

### Methods

> [!TIP]
> **Working with UI-Generated Graphs?**
>
> If your `WorkflowGraph` is generated by a UI library (like React Flow), it often contains extra properties for positioning and styling. You can use the `sanitizeGraph` utility to clean this data before passing it to the builder.
>
> ```typescript
> import { GraphBuilder, sanitizeGraph } from 'flowcraft'
>
> const rawGraphFromUI = { nodes: [/* ... with pos props */], edges: [/* ... */] }
> const cleanGraph = sanitizeGraph(rawGraphFromUI)
>
> const builder = new GraphBuilder(...)
> const { blueprint } = builder.buildBlueprint(cleanGraph)
> ```

#### `.buildBlueprint(graph: WorkflowGraph): { blueprint: WorkflowBlueprint }`

This is the **primary method for building distributable workflows**. It takes a `WorkflowGraph` definition and compiles it into a `WorkflowBlueprint`. The blueprint is a serializable, static representation of the flattened and optimized workflow graph. It contains all the information a `BlueprintExecutor` needs to run the workflow, without any dependencies on the builder itself.

-   `graph`: The `WorkflowGraph` object to build from.

**Returns**: An object containing the `blueprint`.

---

#### `.build(graph: WorkflowGraph, log?: boolean): BuildResult`

A convenience method for **in-memory execution**. It takes a graph definition, builds a `WorkflowBlueprint` internally, and immediately hydrates it into a runnable `Flow` instance using a `BlueprintExecutor`.

This method is ideal for rapid development, testing, or for applications where the workflow is defined and executed in the same process.

-   `graph`: The `WorkflowGraph` object to build from.
-   `log?: boolean`: If `true`, a Mermaid diagram of the final, flattened graph will be logged.

**The `BuildResult` Object**:
-   `flow: Flow`: The fully wired, executable `Flow` instance.
-   `nodeMap: Map<string, AbstractNode>`: A map of all created node instances, keyed by their unique, namespaced ID from the flattened graph.
-   `predecessorCountMap: Map<string, number>`: A map of each node's ID to the number of its direct predecessors. Essential for fan-in logic in custom executors.
-   `originalPredecessorIdMap: Map<string, string[]>`: A map of each node's ID to an array of its logical data-producing predecessors' **original, un-namespaced IDs**. This is critical for distributed executors.

> [!TIP]
> The `nodeMap` returned by `.build()` is the most efficient way to get a reference to a specific node instance within a built flow. It provides an instant, O(1) lookup.
>
> ```typescript
> const { flow, nodeMap } = builder.build(myGraph)
> const specificNode = nodeMap.get('my-node-id')
> ```

---

## `WorkflowBlueprint`

The serializable, static artifact produced by `GraphBuilder.buildBlueprint()`. This is the "compiled" workflow that can be stored in a database, sent over a network, and executed by any worker running a `BlueprintExecutor`.

### Interface

```typescript
interface WorkflowBlueprint {
	// The final, flattened list of node definitions.
	nodes: GraphNode[]
	// The final, flattened list of edge definitions.
	edges: GraphEdge[]
	// The ID of the node where the flow should start.
	startNodeId: string
	// A map of all node IDs to their direct predecessor count.
	predecessorCountMap: Record<string, number>
	// A map of node IDs to their logical data-producing predecessors' original IDs.
	originalPredecessorIdMap: Record<string, string[]>
}
```

> [!TIP]
> **`buildBlueprint` vs. `build`**
>
> - Use **`.buildBlueprint()`** when you need to separate the build step from the run step (e.g., in a distributed system where one service builds the plan and workers execute it).
> - Use **`.build()`** for monolithic applications or tests where you want to immediately get a runnable `Flow` instance.

---

## `BlueprintExecutor`

The execution engine designed specifically to run a `WorkflowBlueprint`. It hydrates the static blueprint into a live, in-memory graph of `Node` instances and then runs it. This is the recommended executor for distributed systems.

### Constructor

`new BlueprintExecutor(blueprint: WorkflowBlueprint, registry: NodeRegistry, nodeOptionsContext?)`

-   `blueprint`: The `WorkflowBlueprint` to execute.
-   `registry`: A `NodeRegistry` (the same one used by the builder) to look up node classes.
-   `nodeOptionsContext?`: An optional object for dependency injection, passed to each node's constructor.

### Properties

-   `.flow: Flow`: The hydrated, runnable `Flow` instance.

### Methods

-   `.run(flow, context, options?)`: Executes the flow.
-   `.getNode(nodeId: string): AbstractNode | undefined`: Retrieves a hydrated node instance by its ID from the blueprint.

---

## `SequenceFlow`

A `Flow` that creates a linear workflow from a sequence of nodes, automatically chaining them in order.

`extends Flow`

### Constructor

`new SequenceFlow(...nodes: AbstractNode[])`

---

## `ParallelFlow`

A `Flow` that executes a collection of nodes concurrently. This is the core of the "fan-out, fan-in" pattern.

`extends Flow`

### Constructor

`new ParallelFlow(nodes: AbstractNode[])`

---

## `BatchFlow` & `ParallelBatchFlow`

**Abstract** `Flow`s that process a collection of items, either sequentially (`BatchFlow`) or concurrently (`ParallelBatchFlow`).

`extends Flow`

### Abstract Members to Implement
- `protected abstract nodeToRun: AbstractNode`: The `Node` instance to execute for each item.
- `async prep(args: NodeArgs): Promise<Iterable<any>>`: A method that returns an iterable of parameter objects, one for each item to be processed.
